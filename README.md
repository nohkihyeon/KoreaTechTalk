# KoreaTechTalk

## 1. 목적 
- 1대다 관계를 형성해주며, 한 객체의 상태에 관심을 가지고 있는 모든 객체에게 객체의 상태가 변하면 항상 자동으로 통보를 해주는 관찰자 패턴 구현

## 2. 개요
- 카카오톡과 같은 메신저 프로그램은 보통 그룹채팅 기능을 제공한다. 그룹채팅은 직관적으로 생각했을 때 관찰자 패턴으로 구현하기 매우 적합한 프로그램이다. 그룹에 새로운 메시지가 도착하면 참여하고 있는 모든 사용자에게 해당 메시지를 전달

## 3. 설계
- ChatRoom, User
  - 그룹채팅 프로그램을 생각해보면 가장 쉽게 떠오르는 객체는 채팅방과 사용자이다.
  - 각 사용자와 채팅방은 id와 방이름으로 식별된다고 가정한다.
  – 채팅방에는 여러 사용자가 참여하고 있을 수 있으며, 한 사용자는 여러 채팅방에 동시에 참여하고 있을 수 있다.
  - 채팅방에 새 글이 게시되면 해당 방의 모든 사용자에게 알려야한다. 이부분을관찰자패턴을이용해 구현해 본다.
  - 사용자는 항상 온라인상태가 아닐 수 있다. 이 부분도 고려하여 구현한다.
  - 실제 메신저 프로그램의 경우 채팅방은 서버에 유지되는 객체이고, 사용자는 클라이언트에 유지되는 객 체이다. 물론 서버에도 사용자를 대신하는 객체를 정의하여 사용하겠지만 이 실습에서는 클라이언트에 유지하는 객체만 있는 형태이다.
  - ChatRoom 객체를 관찰 대상, User 객체를 관찰자로 모델링한다, 하지만 ChatRoom 객체는 User 객체의 목록을 유지하지 않고 사용자의 ID만 유지하고, 절대 User 객체와 직접 상호작용하지 않는다
- ChatMessage: 채팅방을 통해 교환되는 메시지의 전송자와 내용을 유지한다. 이 실습에서는 텍스트 메시지만 교환가능하다고 가정 
- ChatRoomLog
  - ChatRoom은 이 방에서 교환된 모든 메시지를 유지 해야하며, 각 사용자도 이 방을 통해 받은 모든 메시지를 유지해야 한다. 채팅방은 교환된 모든 메시지를 유지해야 하지만 사용자는 자신이 가입된 시 점부터 자신이 최근에 받은 메시지까지만 유지해야 한다. 따라서 채팅방과 사용자가 유지하는 정보가 다를 수 있다.
  - 채팅방과 각 사용자가 유지하는 메시지 목록은 ChatRoomLog에 유지
  - 실제 메신저 프로그램에서는 교환되는 메시지를 유지하는 기간이 정해져 있을 수 있다.
- ChatServer
  - 통신 서버와 데이터베이스 서버를 대신하는 객체
  - 통신 서버: 사용자는 이 서버를 이용하여 메시지를 전송하고, 채팅방은 이 서버를 이용하여 메시지가 도착하였을 때 이 방의 소속된 사용자에게 이 메시지를 전달
    - 일반적으로 채팅 서버는 인라인(inline) 방식으로 통신한다. 모든 메시지는 일차적으로 채팅 서버에 전달되면 채팅 서버가 각 사용자에게 메시지를 전달한다. 즉, 사용자 간에 직접 통신을 하지 않는다. 
- 통신 흐름: 사용자가 사용자 뷰(UserChatWindow)를 이용하여 특정 채팅방을 선택하고 메시지를 전송 할 수 있다. 메시지의 전송은 ChatServer의 sendMessage 메소드가 활용된다. 이 메소드는 메시지를 ChatRoom에 등록한다. ChatRoom은 관찰자 패턴의 관찰 대상이 되어 이 방에 가입된 모든 사용자에게 updateUsers를 이용하여 새 메시지를 전달한다. 이 메소드는 내부적으로 ChatServer의 forwardMessage 를 이용
- 전략패턴을 포함하여 특정 패턴을 사용 할 경우 추상화와 DIP원칙에 충실히 구현하기 위해 상위타입이나 interface를 많이 활용한다. 관찰자 패턴은 관찰 대상(subject) interface와 관찰자(observer) interface를 정의하고, 관찰자 대상 역할을 할 구체적 클래스나 관찰자 역할을 할 구체적 클래스는 이들을 구현하도록 한다. 이 실습에서는 이와 같은 상위 타입의 interface를 사용하지 않고 구현한다. 만약 관찰자 대상의 종류가 다양하고 관찰자도 다양하면 이 추상화는 반드시 필요
